/**
OpenAI API Chat Completions

Standards: https://platform.openai.com/docs/api-reference/completions
*/
module openai.chat;

import mir.algebraic;
import mir.serde;
import mir.string_map;
import std.math;

import openai.common;
import openai.completion : CompletionUsage;

@safe:

@serdeIgnoreUnexpectedKeys
struct ChatMessageToolCall
{
    string id;

    string type = "function";

    @serdeKeys("function")
    ChatMessageFunctionCall function_;
}

@serdeIgnoreUnexpectedKeys
struct ChatMessageFunctionCall
{
    /**
     * The name of the function to call.
     */
    @serdeOptional
    @serdeIgnoreDefault
    string name;

    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     */
    @serdeOptional
    @serdeIgnoreDefault
    string arguments;
}

///
struct ChatCompletionFunction
{
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    string name;

    /**
     * The description of what the function does.
     */
    string description;

    /**
     * The parameters the functions accepts, described as a JSON Schema object.
     */
    JsonValue parameters;

    /** 
     * The parameters the functions accepts, described as a JSON Schema object.
     */
    @serdeOptional
    @serdeIgnoreDefault
    bool strict;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatCompletionTool
{
    string type = "function";

    @serdeKeys("function")
    ChatCompletionFunction function_;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatCompletionToolChoiceInfo
{
    string type = "function";

    @serdeKeys("function")
    ChatCompletionToolFunctionChoice function_;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatCompletionToolFunctionChoice
{
    string name;
}

///
alias ChatCompletionToolChoice = Algebraic!(string, ChatCompletionToolChoiceInfo);

///
@serdeIgnoreUnexpectedKeys
struct ChatUserMessageTextContent
{
    string type = "text";
    string text;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatUserMessageImageContent
{
    string type = "image_url";
    @serdeKeys("image_url")
    string imageUrl;
}

///
alias ChatUserMessageContentItem = Algebraic!(ChatUserMessageTextContent, ChatUserMessageImageContent);
///
alias ChatMessageContent = Algebraic!(typeof(null), string, ChatUserMessageContentItem[]);

///
@serdeIgnoreUnexpectedKeys
struct ChatMessage
{
    ///
    @serdeOptional
    @serdeIgnoreDefault
    string role;

    /// **Required**
    ChatMessageContent content;

    /// Optional
    @serdeOptional
    @serdeIgnoreDefault
    string name = null;

    /// Optional
    @serdeKeys("function_call")
    @serdeOptional
    @serdeIgnoreDefault
    Nullable!ChatMessageFunctionCall functionCall = null;

    /// Optional
    @serdeKeys("tool_calls")
    @serdeOptional
    @serdeIgnoreDefault
    ChatMessageToolCall[] toolCalls;

    /// Optional
    @serdeKeys("tool_call_id")
    @serdeOptional
    @serdeIgnoreDefault
    string toolCallId;

    /// concat all text content in the message
    string getAllTextContent() const
    {
        import std.array : Appender;

        Appender!string appender;
        
        content.optionalMatch!(
            (string text) {
                appender.put(text);
                appender.put("\n");
            },
            (ChatUserMessageContentItem[] items) {
                foreach (item; items)
                {
                    item.optionalMatch!(
                        (ChatUserMessageTextContent textContent) {
                            appender.put(textContent.text);
                            appender.put("\n");
                        }
                    );
                }
            }
        );
        
        return appender.data;
    }
}

///
ChatMessage systemChatMessage(string content, string name = null)
{
    return ChatMessage("system", ChatMessageContent(content), name);
}

/// ditto
ChatMessage developerChatMessage(string content, string name = null)
{
    return ChatMessage("developer", ChatMessageContent(content), name);
}

/// ditto
unittest
{
    auto message = systemChatMessage("You are helpful AI assistant.");
    assert(message.role == "system");
    assert(message.content.get!string() == "You are helpful AI assistant.");

    import mir.ser.json;

    assert(serializeJson(message) == `{"role":"system","content":"You are helpful AI assistant."}`);
}

/// ditto
unittest
{
    auto message = systemChatMessage("You are helpful AI assistant.", "ChatGPT");
    assert(message.role == "system");
    assert(message.content.get!string() == "You are helpful AI assistant.");
    assert(message.name == "ChatGPT");

    import mir.ser.json;

    assert(serializeJson(
            message) == `{"role":"system","content":"You are helpful AI assistant.","name":"ChatGPT"}`);
}

/// ditto
unittest
{
    auto message = developerChatMessage("You are helpful AI assistant.", "ChatGPT");
    assert(message.role == "developer");
    assert(message.content.get!string() == "You are helpful AI assistant.");
    assert(message.name == "ChatGPT");

    import mir.ser.json;

    assert(serializeJson(
            message) == `{"role":"developer","content":"You are helpful AI assistant.","name":"ChatGPT"}`);
}

///
ChatMessage userChatMessage(string content, string name = null)
{
    return ChatMessage("user", ChatMessageContent(content), name);
}

/// ditto
ChatMessage userChatMessage(string[] contents, string name = null)
{
    auto items = new ChatUserMessageContentItem[](contents.length);
    foreach (i, message; contents)
    {
        items[i] = ChatUserMessageContentItem(ChatUserMessageTextContent("text", message));
    }
    return ChatMessage("user", ChatMessageContent(items), name);
}

/// ditto
unittest
{
    auto message = userChatMessage("Hello, how can I help you?");
    assert(message.role == "user");
    assert(message.content.get!string() == "Hello, how can I help you?");

    import mir.ser.json;

    assert(serializeJson(message) == `{"role":"user","content":"Hello, how can I help you?"}`);
}

/// ditto
unittest
{
    auto message = userChatMessage("How does this work?", "User123");
    assert(message.role == "user");
    assert(message.content.get!string() == "How does this work?");
    assert(message.name == "User123");

    import mir.ser.json;

    assert(serializeJson(
            message) == `{"role":"user","content":"How does this work?","name":"User123"}`);
}

///
ChatMessage userChatMessageWithImages(string text, string[] imageUrls, string name = null)
{
    ChatUserMessageContentItem[] contentItems;

    ChatUserMessageTextContent textContent;
    textContent.text = text;

    contentItems ~= ChatUserMessageContentItem(textContent);

    foreach (imageUrl; imageUrls)
    {
        ChatUserMessageImageContent imageContent;
        imageContent.imageUrl = imageUrl;
        contentItems ~= ChatUserMessageContentItem(imageContent);
    }

    return ChatMessage("user", ChatMessageContent(contentItems), name);
}

/// ditto
unittest
{
    string text = "Check out these images:";
    string[] imageUrls = [
        "https://example.com/image1.jpg", "https://example.com/image2.jpg"
    ];
    string name = "User123";

    auto message = userChatMessageWithImages(text, imageUrls, name);

    assert(message.role == "user");
    assert(message.name == name);

    auto content = message.content.get!(ChatUserMessageContentItem[]);

    assert(content.length == 3); // テキストメッセージと2つの画像URL
    assert(content[0].get!ChatUserMessageTextContent().text == text);
    assert(content[1].get!ChatUserMessageImageContent().imageUrl == imageUrls[0]);
    assert(content[2].get!ChatUserMessageImageContent().imageUrl == imageUrls[1]);
}

/// ditto
unittest
{
    string text = "Check out these images:";
    string[] imageUrls = [
        "https://example.com/image1.jpg", "https://example.com/image2.jpg"
    ];
    string name = "User12345";

    auto message = userChatMessageWithImages(text, imageUrls, name);

    import mir.ser.json;

    string jsonString = serializeJson(message);

    string expectedJson = `{"role":"user","content":[{"type":"text","text":"Check out these images:"},{"type":"image_url","image_url":"https://example.com/image1.jpg"},{"type":"image_url","image_url":"https://example.com/image2.jpg"}],"name":"User12345"}`;

    assert(jsonString == expectedJson);
}

///
ChatMessage assistantChatMessage(string content, string name = null)
{
    return ChatMessage("assistant", ChatMessageContent(content), name);
}

///
ChatMessage toolChatMessage(string name, string content, string toolCallId)
{
    ChatMessage message;
    message.role = "tool";
    message.name = name;
    message.content = content;
    message.toolCallId = toolCallId;
    return message;
}

///
deprecated("Deprecated in favor of toolChatMessage.")
ChatMessage functionChatMessage(string functionName, string functionResponseJson)
{
    return ChatMessage("function", ChatMessageContent(functionResponseJson), functionName);
}

/// 
struct ResponseFormatJsonSchema
{
    ///
    string name;

    ///
    bool strict = true;

    ///
    JsonValue schema;
}

///
struct ResponseFormat
{
    /// 
    string type;

    ///
    @serdeKeys("json_schema")
    @serdeOptional
    @serdeIgnoreDefault
    Nullable!ResponseFormatJsonSchema jsonSchema;
}

///
ResponseFormat jsonResponseFormat(string name, JsonValue jsonSchema)
{
    auto format = ResponseFormat();
    format.type = "json_schema";
    format.jsonSchema = ResponseFormatJsonSchema(name, true, jsonSchema);
    return format;
}

///
struct ChatCompletionPredictionContentParam
{
    string type = "content";

    ChatMessageContent content;
}

///
struct ChatCompletionAudioParam
{
    /// format: Required[Literal["wav", "mp3", "flac", "opus", "pcm16"]]
    string format;

    /// voice: Required[Literal["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse"]]
    string voice;
}

/// Valid values for `ChatCompletionRequest.reasoningEffort`
enum ReasoningEffortLow = "low";
/// ditto
enum ReasoningEffortMedium = "medium";
/// ditto
enum ReasoningEffortHigh = "high";

///
struct ChatCompletionRequest
{
    ///
    @serdeIgnoreDefault
    string model;

    ///
    ChatMessage[] messages;

    ///
    @serdeIgnoreDefault
    string store;

    ///
    @serdeIgnoreDefault
    @serdeKeys("reasoning_effort")
    /// Use `ReasoningEffortLow`, `ReasoningEffortMedium` or `ReasoningEffortHigh`.
    string reasoningEffort;

    ///
    @serdeIgnoreDefault
    StringMap!string metadata;

    //deprecated("This value is now deprecated in favor of max_completion_tokens, and is not compatible with o1 series models.")
    ///
    @serdeIgnoreDefault
    @serdeKeys("max_tokens")
    uint maxTokens;

    /// 
    @serdeIgnoreDefault
    @serdeKeys("max_completion_tokens")
    uint maxCompletionTokens;

    ///
    @serdeIgnoreDefault
    double temperature = 1;

    ///
    @serdeIgnoreDefault
    @serdeKeys("top_p")
    double topP = 1;

    ///
    @serdeIgnoreDefault
    uint n = 1;

    ///
    @serdeIgnoreDefault
    string[] modalities;

    ///
    @serdeIgnoreDefault
    Nullable!ChatCompletionPredictionContentParam prediction = null;

    ///
    @serdeIgnoreDefault
    Nullable!ChatCompletionAudioParam audio = null;

    ///
    @serdeIgnoreDefault
    bool stream = false;

    ///
    @serdeIgnoreDefault
    bool echo = false;

    ///
    @serdeIgnoreDefault
    @serdeKeys("service_tier")
    string serviceTier = "auto";

    ///
    @serdeIgnoreDefault
    StopToken stop = null;

    ///
    @serdeIgnoreDefault
    @serdeIgnoreOutIf!isNaN @serdeKeys("presence_penalty")
    double presencePenalty = 0;

    ///
    @serdeIgnoreDefault
    @serdeIgnoreOutIf!isNaN @serdeKeys("frequency_penalty")
    double frequencyPenalty = 0;

    @serdeIgnoreDefault
    @serdeKeys("response_format")
    Nullable!ResponseFormat responseFormat = null;

    @serdeIgnoreDefault
    Nullable!int seed = null;

    version (none)
    {
        ///
        @serdeIgnoreDefault
        @serdeKeys("logit_bias")
        double[string] logitBias; // TODO test
    }

    ///
    @serdeIgnoreDefault
    ChatCompletionTool[] tools = null;

    ///
    @serdeIgnoreDefault
    @serdeKeys("tool_choice")
    ChatCompletionToolChoice toolChoice = null;

    ///
    @serdeIgnoreDefault
    @serdeKeys("parallel_tool_calls")
    bool parallelToolCalls = true;

    ///
    @serdeIgnoreDefault
    string user = null;

    ///
    @serdeIgnoreDefault
    Nullable!bool logprobs = null;

    @serdeIgnoreDefault
    Nullable!uint top_logprobs = null;
}

unittest
{
    ChatCompletionTool tool1;
    tool1.type = "function";
    tool1.function_.name = "tool1";
    tool1.function_.description = "Description of tool1";
    tool1.function_.parameters = JsonValue("{}");

    ChatCompletionTool tool2;
    tool2.type = "function";
    tool2.function_.name = "tool2";
    tool2.function_.description = "Description of tool2";
    tool2.function_.parameters = JsonValue("{}");

    ChatCompletionRequest request;
    request.model = "gpt-4o-mini";
    request.messages = [
        userChatMessage("Hello, how can I help you?"),
        toolChatMessage("tool1", "This is a tool1 result", "tool1_call")
    ];

    request.tools = [tool1, tool2];
    request.toolChoice = "auto";

    assert(request.tools.length == 2);
    assert(request.tools[0].type == "function");
    assert(request.tools[0].function_.name == "tool1");
    assert(request.tools[1].type == "function");
    assert(request.tools[1].function_.name == "tool2");
}

unittest
{
    ChatCompletionTool tool3;
    tool3.type = "function";
    tool3.function_.name = "tool3";
    tool3.function_.description = "Description of tool3";
    tool3.function_.parameters = JsonValue("{}");

    ChatCompletionToolChoiceInfo toolChoiceInfo;
    toolChoiceInfo.type = "function";
    toolChoiceInfo.function_.name = "tool3";

    ChatCompletionRequest request;
    request.model = "gpt-4o-mini";
    request.messages = [
        userChatMessage("Hello, how can I help you?"),
        toolChatMessage("tool1", "This is a tool1 result", "tool1_call")
    ];
    request.tools = [tool3];
    request.toolChoice = ChatCompletionToolChoice(toolChoiceInfo);

    assert(request.toolChoice.get!ChatCompletionToolChoiceInfo().type == "function");
    assert(request.toolChoice.get!ChatCompletionToolChoiceInfo().function_.name == "tool3");
}

unittest
{
    ChatCompletionRequest request;
    request.model = "gpt-4o-mini";
    request.maxCompletionTokens = 20;
    request.messages = [
        systemChatMessage("Welcome!"),
        userChatMessage("How can I use the tools?", "User123"),
    ];

    ChatCompletionTool tool;
    tool.function_.name = "sample_function";
    tool.function_.description = "Sample tool function";
    tool.function_.parameters = JsonSchema.string_("tool argument");

    request.tools ~= tool;
    request.toolChoice = "auto";

    import mir.ser.json;

    string jsonString = serializeJson(request);

    string expectedJson = `{"model":"gpt-4o-mini","messages":[{"role":"system","content":"Welcome!"},{"role":"user","content":"How can I use the tools?","name":"User123"}],"max_completion_tokens":20,"tools":[{"type":"function","function":{"name":"sample_function","description":"Sample tool function","parameters":{"type":"string","description":"tool argument"}}}],"tool_choice":"auto"}`;

    assert(jsonString == expectedJson, jsonString ~ "\n" ~ expectedJson);
}

unittest{
    const errorJson = `{
      "index": 0,
      "message": {
        "role": "assistant",
        "content": null,
        "tool_calls": [
          {
            "id": "call_yRyhjp0JMZCquJKRoPOSziS1",
            "type": "function",
            "function": {
              "name": "add",
              "arguments": "{\n  \"a\": 3,\n  \"b\": 5\n}"
            }
          }
        ]
      },
      "logprobs": null,
      "finish_reason": "tool_calls"
    }`;

    import mir.deser.json;
    auto choice = deserializeJson!ChatChoice(errorJson);
}

version (none) unittest
{
    const errorJson = `{
  "id": "chatcmpl-8o4Ov7YkYueWBllPDLhCxcC68CojX",
  "object": "chat.completion",
  "created": 1706944009,
  "model": "gpt-4o-mini",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": null,
        "tool_calls": [
          {
            "id": "call_yRyhjp0JMZCquJKRoPOSziS1",
            "type": "function",
            "function": {
              "name": "add",
              "arguments": "{\n  \"a\": 3,\n  \"b\": 5\n}"
            }
          }
        ]
      },
      "logprobs": null,
      "finish_reason": "tool_calls"
    }
  ],
  "usage": {
    "prompt_tokens": 124,
    "completion_tokens": 21,
    "total_tokens": 145
  },
  "system_fingerprint": null
}`;
    
    import mir.deser.json;

    auto response = deserializeJson!ChatCompletionResponse(errorJson);
}
///
ChatCompletionRequest chatCompletionRequest(return scope string model, return scope ChatMessage[] messages, uint maxTokens, double temperature)
{
    auto request = ChatCompletionRequest();
    request.model = model;
    request.messages = messages;
    request.maxCompletionTokens = maxTokens;
    request.temperature = temperature;
    return request;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatChoice
{
    ///
    size_t index;

    ///
    ChatMessage message;

    ///
    @serdeKeys("finish_reason")
    string finishReason;

    ///
    Nullable!float logprobs;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatCompletionResponse
{
    ///
    string id;

    ///
    string object;

    ///
    ulong created;

    ///
    string model;

    ///
    ChatChoice[] choices;

    ///
    CompletionUsage usage;

    ///
    @serdeKeys("system_fingerprint")
    string systemFingerprint;
}
