/**
OpenAI API Chat Completions

Standards: https://platform.openai.com/docs/api-reference/completions
*/
module openai.chat;

import mir.algebraic;
import mir.serde;
import mir.string_map;
import std.math;

import openai.common;
import openai.completion : CompletionUsage;

@safe:

@serdeIgnoreUnexpectedKeys
@serdeDiscriminatedField("type", "function")
struct ChatMessageToolCall
{
    string id;

    @serdeKeys("function")
    ChatMessageFunctionCall function_;
}

@serdeIgnoreUnexpectedKeys
struct ChatMessageFunctionCall
{
    /**
     * The name of the function to call.
     */
    @serdeOptional
    @serdeIgnoreDefault
    string name;

    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     */
    @serdeOptional
    @serdeIgnoreDefault
    string arguments;
}

///
struct ChatCompletionFunction
{
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    string name;

    /**
     * The description of what the function does.
     */
    string description;

    /**
     * The parameters the functions accepts, described as a JSON Schema object.
     */
    JsonValue parameters;

    /**
     * The parameters the functions accepts, described as a JSON Schema object.
     */
    @serdeOptional
    @serdeIgnoreDefault
    bool strict;
}

///
@serdeIgnoreUnexpectedKeys
@serdeDiscriminatedField("type", "function")
struct ChatCompletionTool
{
    @serdeKeys("function")
    ChatCompletionFunction function_;
}

///
@serdeIgnoreUnexpectedKeys
@serdeDiscriminatedField("type", "function")
struct ChatCompletionToolChoiceInfo
{
    @serdeKeys("function")
    ChatCompletionToolFunctionChoice function_;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatCompletionToolFunctionChoice
{
    string name;
}

///
alias ChatCompletionToolChoice = Algebraic!(string, ChatCompletionToolChoiceInfo);

///
@serdeIgnoreUnexpectedKeys
@serdeDiscriminatedField("type", "text")
struct ChatUserMessageTextContent
{
    string text;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatUserMessageImageUrl
{
    string url;

    @serdeOptional
    @serdeIgnoreDefault
    string detail;
}

///
@serdeIgnoreUnexpectedKeys
@serdeDiscriminatedField("type", "image_url")
struct ChatUserMessageImageContent
{
    @serdeKeys("image_url")
    ChatUserMessageImageUrl imageUrl;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatUserMessageFile
{
    @serdeKeys("file_id")
    string fileId;
}

@serdeIgnoreUnexpectedKeys
@serdeDiscriminatedField("type", "file")
struct ChatUserMessageFileContent
{
    @serdeKeys("file")
    ChatUserMessageFile file;
}

///
alias ChatUserMessageContentItem = Algebraic!(
    ChatUserMessageTextContent,
    ChatUserMessageImageContent,
    ChatUserMessageFileContent);
///
alias ChatMessageContent = Algebraic!(typeof(null), string, ChatUserMessageContentItem[]);

///
@serdeIgnoreUnexpectedKeys
struct ChatMessage
{
    ///
    @serdeOptional
    @serdeIgnoreDefault
    string role;

    /// **Required**
    ChatMessageContent content;

    /// Optional
    @serdeOptional
    @serdeIgnoreDefault
    string name = null;

    /// Optional
    @serdeKeys("function_call")
    @serdeOptional
    @serdeIgnoreDefault
    Nullable!ChatMessageFunctionCall functionCall = null;

    /// Optional
    @serdeKeys("tool_calls")
    @serdeOptional
    @serdeIgnoreDefault
    ChatMessageToolCall[] toolCalls;

    /// Optional
    @serdeKeys("tool_call_id")
    @serdeOptional
    @serdeIgnoreDefault
    string toolCallId;

    /// concat all text content in the message
    string getAllTextContent() const
    {
        import std.array : Appender;

        Appender!string appender;

        // dfmt off
        content.optionalMatch!(
            (string text) {
                appender.put(text);
                appender.put("\n");
            },
            (ChatUserMessageContentItem[] items) {
                foreach (item; items)
                {
                    item.optionalMatch!(
                        (ChatUserMessageTextContent textContent) {
                            appender.put(textContent.text);
                            appender.put("\n");
                        }
                    );
                }
            }
        );
        // dfmt on

        import std.string : stripRight;

        return appender.data.stripRight("\n");
    }
}

/**
 * Convenience helper to construct a system role message.
 *
 * Params:
 *     content - Text of the system prompt.
 *     name    - Optional name associated with the message.
 */
ChatMessage systemChatMessage(string content, string name = null)
{
    return ChatMessage("system", ChatMessageContent(content), name);
}

/**
 * Helper for building a `developer` role message.
 *
 * Params:
 *     content - Developer instructions for the model.
 *     name    - Optional name attached to the message.
 */
ChatMessage developerChatMessage(string content, string name = null)
{
    return ChatMessage("developer", ChatMessageContent(content), name);
}

/// ditto
unittest
{
    auto message = systemChatMessage("You are helpful AI assistant.");
    assert(message.role == "system");
    assert(message.content.get!string() == "You are helpful AI assistant.");

    import mir.ser.json;

    assert(serializeJson(message) == `{"role":"system","content":"You are helpful AI assistant."}`);
}

/// ditto
unittest
{
    auto message = systemChatMessage("You are helpful AI assistant.", "ChatGPT");
    assert(message.role == "system");
    assert(message.content.get!string() == "You are helpful AI assistant.");
    assert(message.name == "ChatGPT");

    import mir.ser.json;

    assert(serializeJson(
            message) == `{"role":"system","content":"You are helpful AI assistant.","name":"ChatGPT"}`);
}

/// ditto
unittest
{
    auto message = developerChatMessage("You are helpful AI assistant.", "ChatGPT");
    assert(message.role == "developer");
    assert(message.content.get!string() == "You are helpful AI assistant.");
    assert(message.name == "ChatGPT");

    import mir.ser.json;

    assert(serializeJson(
            message) == `{"role":"developer","content":"You are helpful AI assistant.","name":"ChatGPT"}`);
}

/**
 * Creates a user role chat message from a single string.
 *
 * Params:
 *     content - The user's input text.
 *     name    - Optional user name.
 */
ChatMessage userChatMessage(string content, string name = null)
{
    return ChatMessage("user", ChatMessageContent(content), name);
}

/// ditto
ChatMessage userChatMessage(string[] contents, string name = null)
{
    auto items = new ChatUserMessageContentItem[](contents.length);
    foreach (i, message; contents)
    {
        items[i] = ChatUserMessageContentItem(ChatUserMessageTextContent(message));
    }
    return ChatMessage("user", ChatMessageContent(items), name);
}

/// ditto
unittest
{
    auto message = userChatMessage("Hello, how can I help you?");
    assert(message.role == "user");
    assert(message.content.get!string() == "Hello, how can I help you?");

    import mir.ser.json;

    assert(serializeJson(message) == `{"role":"user","content":"Hello, how can I help you?"}`);
}

/// ditto
unittest
{
    auto message = userChatMessage("How does this work?", "User123");
    assert(message.role == "user");
    assert(message.content.get!string() == "How does this work?");
    assert(message.name == "User123");

    import mir.ser.json;

    assert(serializeJson(
            message) == `{"role":"user","content":"How does this work?","name":"User123"}`);
}

unittest
{
    auto message = userChatMessage("Hello");

    auto text = message.getAllTextContent();

    import std.algorithm.searching : endsWith;

    assert(text == "Hello");
    assert(!text.endsWith("\n"));
}

///
ChatMessage userChatMessageWithImages(string text, string[] imageUrls, string name = null)
{
    ChatUserMessageContentItem[] contentItems;

    ChatUserMessageTextContent textContent;
    textContent.text = text;

    contentItems ~= ChatUserMessageContentItem(textContent);

    foreach (imageUrl; imageUrls)
    {
        ChatUserMessageImageContent imageContent;
        imageContent.imageUrl = ChatUserMessageImageUrl(imageUrl);
        contentItems ~= ChatUserMessageContentItem(imageContent);
    }

    return ChatMessage("user", ChatMessageContent(contentItems), name);
}

/// ditto
unittest
{
    string text = "Check out these images:";
    string[] imageUrls = [
        "https://example.com/image1.jpg", "https://example.com/image2.jpg"
    ];
    string name = "User123";

    auto message = userChatMessageWithImages(text, imageUrls, name);

    assert(message.role == "user");
    assert(message.name == name);

    auto content = message.content.get!(ChatUserMessageContentItem[]);

    assert(content.length == 3); // テキストメッセージと2つの画像URL
    assert(content[0].get!ChatUserMessageTextContent().text == text);
    assert(content[1].get!ChatUserMessageImageContent().imageUrl.url == imageUrls[0]);
    assert(content[2].get!ChatUserMessageImageContent().imageUrl.url == imageUrls[1]);
}

/// ditto
unittest
{
    string text = "Check out these images:";
    string[] imageUrls = [
        "https://example.com/image1.jpg", "https://example.com/image2.jpg"
    ];
    string name = "User12345";

    auto message = userChatMessageWithImages(text, imageUrls, name);

    import mir.ser.json;

    string jsonString = serializeJson(message);

    string expectedJson = `{"role":"user","content":[{"type":"text","text":"Check out these images:"},{"type":"image_url","image_url":{"url":"https://example.com/image1.jpg"}},{"type":"image_url","image_url":{"url":"https://example.com/image2.jpg"}}],"name":"User12345"}`;

    assert(jsonString == expectedJson);
}

///
ChatMessage userChatMessageWithFile(string text, string fileId, string name = null)
{
    ChatUserMessageContentItem[] contentItems;

    ChatUserMessageFileContent fileContent;
    fileContent.file.fileId = fileId;
    contentItems ~= ChatUserMessageContentItem(fileContent);

    ChatUserMessageTextContent textContent;
    textContent.text = text;
    contentItems ~= ChatUserMessageContentItem(textContent);

    return ChatMessage("user", ChatMessageContent(contentItems), name);
}

/// ditto
unittest
{
    string text = "What is the first dragon?";
    string fileId = "file_123";
    string name = "UserX";

    auto message = userChatMessageWithFile(text, fileId, name);

    assert(message.role == "user");
    assert(message.name == name);

    auto content = message.content.get!(ChatUserMessageContentItem[]);

    assert(content.length == 2);
    assert(content[0].get!ChatUserMessageFileContent().file.fileId == fileId);
    assert(content[1].get!ChatUserMessageTextContent().text == text);
}

/// ditto
unittest
{
    string text = "What is the first dragon?";
    string fileId = "file_456";

    auto message = userChatMessageWithFile(text, fileId);

    import mir.ser.json;

    string jsonString = serializeJson(message);

    string expectedJson = `{"role":"user","content":[{"type":"file","file":{"file_id":"file_456"}},{"type":"text","text":"What is the first dragon?"}]}`;

    assert(jsonString == expectedJson);
}

///
ChatMessage assistantChatMessage(string content, string name = null)
{
    return ChatMessage("assistant", ChatMessageContent(content), name);
}

///
ChatMessage toolChatMessage(string name, string content, string toolCallId)
{
    ChatMessage message;
    message.role = "tool";
    message.name = name;
    message.content = content;
    message.toolCallId = toolCallId;
    return message;
}

///
deprecated("Deprecated in favor of toolChatMessage.")
ChatMessage functionChatMessage(string functionName, string functionResponseJson)
{
    return ChatMessage("function", ChatMessageContent(functionResponseJson), functionName);
}

///
struct ResponseFormatJsonSchema
{
    ///
    string name;

    ///
    bool strict = true;

    ///
    JsonValue schema;
}

///
struct ResponseFormat
{
    ///
    string type;

    ///
    @serdeKeys("json_schema")
    @serdeOptional
    @serdeIgnoreDefault
    Nullable!ResponseFormatJsonSchema jsonSchema;
}

///
ResponseFormat jsonResponseFormat(string name, JsonValue jsonSchema)
{
    auto format = ResponseFormat();
    format.type = "json_schema";
    format.jsonSchema = ResponseFormatJsonSchema(name, true, jsonSchema);
    return format;
}

///
struct ChatCompletionPredictionContentParam
{
    string type = "content";

    ChatMessageContent content;
}

///
struct ChatCompletionAudioParam
{
    /// format: Required[Literal["wav", "mp3", "flac", "opus", "pcm16"]]
    string format;

    /// voice: Required[Literal["alloy", "ash", "ballad", "coral", "echo", "sage", "shimmer", "verse"]]
    string voice;
}

/// Valid values for `ChatCompletionRequest.reasoningEffort`
enum ReasoningEffortLow = "low";
/// ditto
enum ReasoningEffortMedium = "medium";
/// ditto
enum ReasoningEffortHigh = "high";

///
struct ChatCompletionRequest
{
    ///
    @serdeIgnoreDefault
    string model;

    ///
    ChatMessage[] messages;

    //@serdeIgnoreDefault
    //string store; /// disabled, see https://platform.openai.com/docs/guides/your-data

    /// Use `ReasoningEffortLow`, `ReasoningEffortMedium` or `ReasoningEffortHigh`.
    @serdeIgnoreDefault
    @serdeKeys("reasoning_effort")
    string reasoningEffort;

    ///
    @serdeIgnoreDefault
    StringMap!string metadata;

    //deprecated("This value is now deprecated in favor of max_completion_tokens, and is not compatible with o1 series models.")
    ///
    @serdeIgnoreDefault
    @serdeKeys("max_tokens")
    uint maxTokens;

    ///
    @serdeIgnoreDefault
    @serdeKeys("max_completion_tokens")
    uint maxCompletionTokens;

    ///
    @serdeIgnoreDefault
    double temperature = 1;

    ///
    @serdeIgnoreDefault
    @serdeKeys("top_p")
    double topP = 1;

    ///
    @serdeIgnoreDefault
    uint n = 1;

    ///
    @serdeIgnoreDefault
    string[] modalities;

    ///
    @serdeIgnoreDefault
    Nullable!ChatCompletionPredictionContentParam prediction = null;

    ///
    @serdeIgnoreDefault
    Nullable!ChatCompletionAudioParam audio = null;

    ///
    @serdeIgnoreDefault
    bool stream = false;

    ///
    @serdeIgnoreDefault
    bool echo = false;

    ///
    @serdeIgnoreDefault
    @serdeKeys("service_tier")
    string serviceTier = "auto";

    ///
    @serdeIgnoreDefault
    StopToken stop = null;

    ///
    @serdeIgnoreDefault
    @serdeIgnoreOutIf!isNaN @serdeKeys("presence_penalty")
    double presencePenalty = 0;

    ///
    @serdeIgnoreDefault
    @serdeIgnoreOutIf!isNaN @serdeKeys("frequency_penalty")
    double frequencyPenalty = 0;

    @serdeIgnoreDefault
    @serdeKeys("response_format")
    Nullable!ResponseFormat responseFormat = null;

    @serdeIgnoreDefault
    Nullable!int seed = null;

    // Reason: mir-algorithm's JsonAlgebraic does not support associative arrays with int or uint keys.
    // @serdeIgnoreDefault
    // @serdeKeys("logit_bias")
    // float[int] logitBias;

    ///
    @serdeIgnoreDefault
    ChatCompletionTool[] tools = null;

    ///
    @serdeIgnoreDefault
    @serdeKeys("tool_choice")
    ChatCompletionToolChoice toolChoice = null;

    ///
    @serdeIgnoreDefault
    @serdeKeys("parallel_tool_calls")
    bool parallelToolCalls = true;

    ///
    @serdeIgnoreDefault
    string user = null;

    ///
    @serdeIgnoreDefault
    Nullable!bool logprobs = null;

    @serdeIgnoreDefault
    Nullable!uint top_logprobs = null;
}

unittest
{
    ChatCompletionTool tool1;
    tool1.function_.name = "tool1";
    tool1.function_.description = "Description of tool1";
    tool1.function_.parameters = JsonValue("{}");

    ChatCompletionTool tool2;
    tool2.function_.name = "tool2";
    tool2.function_.description = "Description of tool2";
    tool2.function_.parameters = JsonValue("{}");

    ChatCompletionRequest request;
    request.model = "gpt-4o-mini";
    request.messages = [
        userChatMessage("Hello, how can I help you?"),
        toolChatMessage("tool1", "This is a tool1 result", "tool1_call")
    ];

    request.tools = [tool1, tool2];
    request.toolChoice = "auto";

    assert(request.tools.length == 2);
    assert(request.tools[0].function_.name == "tool1");
    assert(request.tools[1].function_.name == "tool2");
}

unittest
{
    ChatCompletionTool tool3;
    tool3.function_.name = "tool3";
    tool3.function_.description = "Description of tool3";
    tool3.function_.parameters = JsonValue("{}");

    ChatCompletionToolChoiceInfo toolChoiceInfo;
    toolChoiceInfo.function_.name = "tool3";

    ChatCompletionRequest request;
    request.model = "gpt-4o-mini";
    request.messages = [
        userChatMessage("Hello, how can I help you?"),
        toolChatMessage("tool1", "This is a tool1 result", "tool1_call")
    ];
    request.tools = [tool3];
    request.toolChoice = ChatCompletionToolChoice(toolChoiceInfo);

    assert(request.toolChoice.get!ChatCompletionToolChoiceInfo().function_.name == "tool3");
}

unittest
{
    ChatCompletionRequest request;
    request.model = "gpt-4o-mini";
    request.maxCompletionTokens = 20;
    request.messages = [
        systemChatMessage("Welcome!"),
        userChatMessage("How can I use the tools?", "User123"),
    ];

    ChatCompletionTool tool;
    tool.function_.name = "sample_function";
    tool.function_.description = "Sample tool function";
    tool.function_.parameters = JsonSchema.string_("tool argument");

    request.tools ~= tool;
    request.toolChoice = "auto";

    import mir.ser.json;

    string jsonString = serializeJson(request);

    string expectedJson = `{"model":"gpt-4o-mini","messages":[{"role":"system","content":"Welcome!"},{"role":"user","content":"How can I use the tools?","name":"User123"}],"max_completion_tokens":20,"tools":[{"type":"function","function":{"name":"sample_function","description":"Sample tool function","parameters":{"type":"string","description":"tool argument"}}}],"tool_choice":"auto"}`;

    assert(jsonString == expectedJson, jsonString ~ "\n" ~ expectedJson);
}

unittest
{
    const errorJson = `{
      "index": 0,
      "message": {
        "role": "assistant",
        "content": null,
        "tool_calls": [
          {
            "id": "call_yRyhjp0JMZCquJKRoPOSziS1",
            "type": "function",
            "function": {
              "name": "add",
              "arguments": "{\n  \"a\": 3,\n  \"b\": 5\n}"
            }
          }
        ]
      },
      "logprobs": null,
      "finish_reason": "tool_calls"
    }`;

    import mir.deser.json;

    auto _ = deserializeJson!ChatChoice(errorJson);
}

version (none) unittest
{
    const errorJson = `{
  "id": "chatcmpl-8o4Ov7YkYueWBllPDLhCxcC68CojX",
  "object": "chat.completion",
  "created": 1706944009,
  "model": "gpt-4o-mini",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": null,
        "tool_calls": [
          {
            "id": "call_yRyhjp0JMZCquJKRoPOSziS1",
            "type": "function",
            "function": {
              "name": "add",
              "arguments": "{\n  \"a\": 3,\n  \"b\": 5\n}"
            }
          }
        ]
      },
      "logprobs": null,
      "finish_reason": "tool_calls"
    }
  ],
  "usage": {
    "prompt_tokens": 124,
    "completion_tokens": 21,
    "total_tokens": 145
  },
  "system_fingerprint": null
}`;

    import mir.deser.json;

    auto _ = deserializeJson!ChatCompletionResponse(errorJson);
}
/**
 * Helper to create a `ChatCompletionRequest` for the `/chat/completions`
 * endpoint.
 *
 * Params:
 *     model       = Chat model ID or deployment.
 *     messages    = Sequence of chat messages to send.
 *     maxTokens   = Maximum completion tokens (defaults to 16 in the
 *                   request struct).
 *     temperature = Sampling temperature (defaults to `1.0`).
 *
 * Returns: Request object consumable by `OpenAIClient.chatCompletion`.
 */
ChatCompletionRequest chatCompletionRequest(return scope string model, return scope ChatMessage[] messages, uint maxTokens, double temperature)
{
    auto request = ChatCompletionRequest();
    request.model = model;
    request.messages = messages;
    request.maxCompletionTokens = maxTokens;
    request.temperature = temperature;
    return request;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatChoice
{
    ///
    size_t index;

    ///
    ChatMessage message;

    ///
    @serdeKeys("finish_reason")
    string finishReason;

    ///
    @serdeOptional
    Nullable!float logprobs;
}

///
@serdeIgnoreUnexpectedKeys
struct ChatCompletionResponse
{
    ///
    string id;

    ///
    string object;

    ///
    ulong created;

    ///
    string model;

    ///
    ChatChoice[] choices;

    ///
    CompletionUsage usage;

    ///
    @serdeKeys("system_fingerprint")
    string systemFingerprint;
}
